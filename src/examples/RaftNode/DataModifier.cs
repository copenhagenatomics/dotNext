using DotNext;
using DotNext.Net.Cluster.Consensus.Raft;
using DotNext.Threading;

namespace RaftNode;

internal sealed class DataModifier : BackgroundService
{
    private readonly IRaftCluster cluster;
    private readonly IKValueProvider valueProvider;

    public DataModifier(IRaftCluster cluster, IKValueProvider provider)
    {
        this.cluster = cluster;
        valueProvider = provider;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        int cycleNumber = 0;
        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken).ConfigureAwait(false);

            var leadershipToken = cluster.LeadershipToken;
            if (!leadershipToken.IsCancellationRequested)
            {
                cycleNumber++;
                var Data = new Dictionary<string, double>(100); 
                switch (cycleNumber % 3)
                {
                    case 0:
                    //simulate sensor data 
                    AsyncWriter.WriteLine("Adding dummy sensor data");
                     
                    for (int i = 0; i < 10; i++)
                    {
                        Data.Add($"s{i}", 100000 + i * 10000 + cycleNumber);
                    }
                    
                    break;
                    case 1:
                    //Send decision cmd 
                    AsyncWriter.WriteLine("send decision cmd");
                    
                    Data.Add("D!", cycleNumber);
                    
                    break;
                    default:
                        double tmpval = 0;
                        if ( valueProvider.Value.TryGetValue("myval", out tmpval))
                        {
                            tmpval += 1;
                        }
                        AsyncWriter.WriteLine($"Saving value {tmpval} generated by the leader node");
                        Data.Add("myval", tmpval);
                        
                        break;
                }

                var source = stoppingToken.LinkTo(leadershipToken);
                try
                {   
                    var entry = new MyLogEntry(Data, cluster.Term);
                    //var entry = new Int64LogEntry { Content = newValue, Term = cluster.Term };

                    await cluster.ReplicateAsync(entry, stoppingToken);
                    
                }
                catch (Exception e)
                {
                    AsyncWriter.WriteLine($"Unexpected error {e}");
                }
                finally
                {
                    source?.Dispose();
                }
            }
        }
    }
}