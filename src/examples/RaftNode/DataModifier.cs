using DotNext;
using DotNext.Net.Cluster.Consensus.Raft;
using DotNext.Threading;

namespace RaftNode;

internal sealed class DataModifier : BackgroundService
{
    private readonly IRaftCluster cluster;
    private readonly IKValueProvider valueProvider;

    public DataModifier(IRaftCluster cluster, IKValueProvider provider)
    {
        this.cluster = cluster;
        valueProvider = provider;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken).ConfigureAwait(false);

            var leadershipToken = cluster.LeadershipToken;
            if (!leadershipToken.IsCancellationRequested)
            {
                double tmpval = 0;
                if ( valueProvider.Value.TryGetValue("myval", out tmpval))
                {
                    tmpval += 1;
                }
                AsyncWriter.WriteLine($"Saving value {tmpval} generated by the leader node");

                var source = stoppingToken.LinkTo(leadershipToken);
                try
                {   
                    var entry = new MyLogEntry("myval", tmpval, cluster.Term);
                    //var entry = new Int64LogEntry { Content = newValue, Term = cluster.Term };
                    await cluster.ReplicateAsync(entry, stoppingToken);
                }
                catch (Exception e)
                {
                    AsyncWriter.WriteLine($"Unexpected error {e}");
                }
                finally
                {
                    source?.Dispose();
                }
            }
        }
    }
}