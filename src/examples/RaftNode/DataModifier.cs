using DotNext;
using DotNext.Diagnostics;
using DotNext.Net.Cluster.Consensus.Raft;

namespace RaftNode;

internal sealed class DataModifier : BackgroundService
{
    private readonly IRaftCluster cluster;
    private readonly ISupplier<BigStruct> valueProvider;

    public DataModifier(IRaftCluster cluster, ISupplier<BigStruct> provider)
    {
        this.cluster = cluster;
        valueProvider = provider;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var i = 0;
        var ts = new Timestamp();
        while (!stoppingToken.IsCancellationRequested)
        {
            var leadershipToken = cluster.LeadershipToken;
            if (!leadershipToken.IsCancellationRequested)
            {
                var newValue = new BigStruct();
                //Console.WriteLine("Saving value generated by the leader node");

                var source = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken, leadershipToken);
                try
                {
                    var entry = new BigLogEntry { Content = newValue, Term = cluster.Term };
                    var ts2 = new DotNext.Diagnostics.Timestamp();
                    await cluster.ReplicateAsync(entry, source.Token);
                    //Console.WriteLine($"Latency {ts2.Elapsed}");
                }
                catch (Exception e)
                {
                    Console.WriteLine("Unexpected error {0}", e);
                }
                finally
                {
                    source?.Dispose();
                }

                if (i is 1000)
                {
                    Console.WriteLine($"Replication time is {ts.Elapsed}");
                    i = 0;
                    ts = new();
                }
                else
                {
                    i += 1;
                }
            }
        }
    }
}